<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BioEcho — Overlay Animation with Fullscreen Video</title>
<style>
  :root{
    --pulse-scale: 1.035;
    --pulse-dur: 2.2s;
    --draw-dur: 1.6s;
    --draw-gap: .15s;
    --logo-width: min(70vw, 560px);

    --overlay-fade: 1s;   /* 覆盖层淡出时长 */
    --video-fade: 1.5s;   /* 视频淡入时长 */
  }

  body{
    margin:0; min-height:100vh;
    background:#ffffff; color:#e6ecff;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;
  }

  /* 全屏背景视频 */
  #demoVideo{
    position:fixed; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    z-index:-1;              
    opacity:0;
    transition:opacity var(--video-fade) ease;
  }
  #demoVideo.show{ opacity:1; }

  .logo-overlay{
    position: fixed; inset: 0;
    display:flex; align-items:center; justify-content:center;
    pointer-events:none;
    z-index: 10;
    opacity:1;
    transition: opacity var(--overlay-fade) ease;
  }
  .logo-overlay.fade-out{ opacity:0; }

  .logo-box{
    width: var(--logo-width);
    max-width: 90vw;
    aspect-ratio: 261/48;
    display:flex; align-items:center; justify-content:center;
    opacity:0;
    transition: opacity .12s linear;
    filter: drop-shadow(0 6px 16px rgba(0,0,0,.25));
  }
  .logo-box.start{ opacity:1; }

  .logo-box.start svg{
    width:100%; height:auto; display:block;
    transform-origin:50% 50%;
    animation: pulse var(--pulse-dur) ease-out 1 both;
  }
  @keyframes pulse{
    0%{transform:scale(1)}
    10%{transform:scale(var(--pulse-scale))}
    18%{transform:scale(1)}
    100%{transform:scale(1)}
  }

  .bioecho-stroke{
    stroke-dasharray: var(--len,0);
    stroke-dashoffset: var(--len,0);
    animation: draw var(--draw-dur) ease-in-out forwards;
    animation-play-state: paused;
    filter: drop-shadow(0 0 4px rgba(0,194,255,0.25));
  }
  .logo-box.start .bioecho-stroke{ animation-play-state: running; }
  @keyframes draw{
    0%  { stroke-dashoffset: var(--len,0); opacity:.9 }
    85% { stroke-dashoffset: 0;           opacity:1 }
    100%{ stroke-dashoffset: 0;           opacity:1 }
  }
</style>
</head>
<body>

  <!-- 背景视频（不循环） -->
  <video id="demoVideo" src="demo1.mp4" muted playsinline></video>

  <!-- Logo -->
  <div class="logo-overlay" id="overlay" aria-hidden="true">
    <div class="logo-box" id="logoBox"></div>
  </div>

<script>
(async function(){
  const overlay = document.getElementById('overlay');
  const box = document.getElementById('logoBox');
  const video = document.getElementById('demoVideo');

  video.loop = false; // 只播放一次

  // 加载 SVG
  let svgText = '';
  try{
    const res = await fetch('./BioEcho-all.svg', { cache:'no-store' });
    if(!res.ok) throw new Error('Failed to load SVG: '+res.status);
    svgText = await res.text();
  }catch(e){
    console.error(e); overlay.style.display='none'; return;
  }

  box.insertAdjacentHTML('afterbegin', svgText);
  const svg = box.querySelector('svg');
  if(!svg){ overlay.style.display='none'; return; }

  const nodes = svg.querySelectorAll('path,line,polyline,polygon,circle,ellipse,rect');
  const hasStroke = (el)=>{
    const aS = el.getAttribute('stroke');
    const aF = el.getAttribute('fill');
    const st = el.getAttribute('style')||'';
    if(aS && aS!=='none') return true;
    if(st.includes('stroke:') && !st.includes('stroke: none')) return true;
    if((aF==='none' || st.includes('fill: none')) && (aS || st.includes('stroke:'))) return true;
    const cs = getComputedStyle(el);
    return cs.stroke && cs.stroke!=='none' && parseFloat(cs.strokeOpacity||'1')>0 && parseFloat(cs.strokeWidth||'0')>0;
  };

  let idx = 0;
  nodes.forEach(el=>{
    if(!hasStroke(el)) return;
    el.classList.add('bioecho-stroke');
    try{
      const len = typeof el.getTotalLength==='function' ? el.getTotalLength() : 0;
      el.style.setProperty('--len', len.toFixed(2));
    }catch(_){}
    el.style.animationDelay = (idx * (parseFloat(getComputedStyle(document.documentElement)
                                   .getPropertyValue('--draw-gap')) || 0.15)) + 's';
    idx++;
  });

  // 延迟 1 秒启动动画
  setTimeout(() => {
    box.classList.add('start');
    waitForAllAnimationsThenPlayVideo();
  }, 1000);

  function waitForAllAnimationsThenPlayVideo(){
    const strokes = svg.querySelectorAll('.bioecho-stroke');
    let remaining = strokes.length + 1;

    const done = () => {
      remaining--;
      if (remaining <= 0) {
        // 所有动画结束后 → 显示并播放视频
        video.classList.add('show');
        video.play().catch(e=>console.log("Autoplay blocked:",e));

        // NEW: 读取 CSS 中的 --video-fade，计算“提前 0.5s”触发淡出
        const root = getComputedStyle(document.documentElement);
        const fadeStr = root.getPropertyValue('--video-fade').trim() || '1.5s';
        const videoFadeMs = toMs(fadeStr);                 // 例如 1.5s -> 1500
        const leadMs = 500;                                // 0.5s 重叠
        const startFadeOutAfter = Math.max(videoFadeMs - leadMs, 0);

        // 在视频淡入结束前 0.5s 开始淡出 Logo
        setTimeout(() => {
          overlay.classList.add('fade-out');
          overlay.addEventListener('transitionend', ()=>{
            overlay.style.display = 'none';
          }, { once:true });
        }, startFadeOutAfter);

        // 兼容：如果浏览器不触发 transitionend，也在淡入完成时兜底隐藏
        video.addEventListener('transitionend', () => {
          // 如果尚未开始淡出，则现在开始；如果已开始则忽略
          if (!overlay.classList.contains('fade-out')) {
            overlay.classList.add('fade-out');
            overlay.addEventListener('transitionend', ()=>{
              overlay.style.display = 'none';
            }, { once:true });
          }
        }, { once:true });
      }
    };

    svg.addEventListener('animationend', (e)=>{
      if (e.animationName === 'pulse') done();
    });
    strokes.forEach(el => el.addEventListener('animationend', done, { once:true }));
  }

  // 工具：把 "1.5s" / "800ms" 解析为毫秒
  function toMs(str){
    const s = String(str).trim();
    if (s.endsWith('ms')) return parseFloat(s);
    if (s.endsWith('s'))  return parseFloat(s) * 1000;
    const n = parseFloat(s);
    return isNaN(n) ? 1500 : n; // 默认 1500ms
  }
})();
</script>

</body>
</html>
